<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Reference Test</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .output { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .header { background: #007bff; color: white; padding: 10px; margin: -20px -20px 20px -20px; border-radius: 8px 8px 0 0; }
        .final-results { background: #28a745; color: white; padding: 10px; border-radius: 5px; margin: 10px 0; }
        .comparison { background: #ffc107; color: black; padding: 10px; border-radius: 5px; margin: 10px 0; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>JavaScript vs Python Cavity Simulator Comparison</h2>
        </div>
        
        <p>This test compares the JavaScript cavity simulator implementation with the Python reference.</p>
        
        <button onclick="runJavaScriptTest()">Run JavaScript Test</button>
        <button onclick="runComparison()">Compare with Python</button>
        <button onclick="clearOutput()">Clear Output</button>
        
        <div id="output"></div>
    </div>

    <script>
        // JavaScript Cavity Simulator (extracted from main simulator)
        class JavaScriptCavitySimulator {
            constructor() {
                // Simulation parameters (EXACTLY matching Python)
                this.dt = 1e-6; // Time step
                this.f0 = 1.3e9; // Cavity frequency
                this.omega0 = 2 * Math.PI * this.f0;
                this.Q_loaded = 3e6; // Loaded Q
                this.R_over_Q = 1036; // R/Q
                this.beta = 1e4; // Coupling
                this.RL = 0.5 * this.R_over_Q * this.Q_loaded;
                
                // RF amplifier gain (CRITICAL: matching Python)
                this.gain_dB = 20 * Math.log10(12e6);
                this.gain_linear = Math.pow(10, this.gain_dB / 20);
                
                // Derived parameters
                this.half_bandwidth = Math.PI * this.f0 / this.Q_loaded;
                
                // Initial state
                this.vc_complex = { real: 0, imag: 0 };
                this.time = 0.0;
                this.step_count = 0;
                
                // Control parameters (matching Python defaults)
                this.amplitude = 1.0;
                this.phase = 0.0; // degrees
                this.frequency_offset = -460.0; // Hz (fsrc in Python)
                this.beam_current = 0.008; // A
                
                console.log('JavaScript Simulator Initialized:');
                console.log(`  Half bandwidth: ${this.half_bandwidth.toExponential(3)} rad/s`);
                console.log(`  Gain (dB): ${this.gain_dB.toFixed(1)}`);
                console.log(`  Gain (linear): ${this.gain_linear.toExponential(3)}`);
                console.log(`  RL: ${this.RL.toExponential(3)} Ohms`);
            }
            
            step() {
                // Update time
                this.time += this.dt;
                this.step_count += 1;
                
                // Random seed for microphonics (simple approach)
                const dw_micr = 2.0 * Math.PI * (Math.random() - 0.5) * 2 * 10;
                
                // RF drive voltage (matching Python exactly)
                let vf_real = 0, vf_imag = 0;
                
                // Base RF signal (matching Python phase and frequency handling)
                const freq_phase = 2 * Math.PI * this.frequency_offset * this.time;
                const static_phase = this.phase * Math.PI / 180;
                const total_phase = static_phase + freq_phase;
                
                const base_real = this.amplitude * Math.cos(total_phase);
                const base_imag = this.amplitude * Math.sin(total_phase);
                
                // Apply amplifier gain (matching Python sim_amp)
                vf_real = base_real * this.gain_linear;
                vf_imag = base_imag * this.gain_linear;
                
                // Beam loading voltage
                const vb_real = -this.RL * this.beam_current;
                const vb_imag = 0;
                
                // Cavity dynamics (matching Python sim_scav_step algorithm)
                const factor_real = 1 - this.dt * this.half_bandwidth;
                const factor_imag = this.dt * dw_micr; // Only microphonics, not RF offset
                
                const drive_factor = 2 * this.half_bandwidth * this.dt;
                const vf_coupled_real = this.beta * vf_real / (this.beta + 1);
                const vf_coupled_imag = this.beta * vf_imag / (this.beta + 1);
                
                const drive_total_real = drive_factor * (vf_coupled_real + vb_real);
                const drive_total_imag = drive_factor * (vf_coupled_imag + vb_imag);
                
                // Complex multiplication and update
                const new_vc_real = (factor_real * this.vc_complex.real - factor_imag * this.vc_complex.imag) + drive_total_real;
                const new_vc_imag = (factor_real * this.vc_complex.imag + factor_imag * this.vc_complex.real) + drive_total_imag;
                
                this.vc_complex.real = new_vc_real;
                this.vc_complex.imag = new_vc_imag;
                
                // Calculate results
                const vc_magnitude = Math.sqrt(this.vc_complex.real**2 + this.vc_complex.imag**2);
                const vc_phase = Math.atan2(this.vc_complex.imag, this.vc_complex.real) * 180 / Math.PI;
                
                // Reflected voltage
                const vr_real = this.vc_complex.real - vf_real;
                const vr_imag = this.vc_complex.imag - vf_imag;
                const vr_magnitude = Math.sqrt(vr_real**2 + vr_imag**2);
                
                // Power calculations (CORRECTED to match Python exactly)
                const R_cavity = this.R_over_Q * this.Q_loaded; // 1036 × 3e6 = 3.108e9 Ohms
                const vf_magnitude_squared = vf_real**2 + vf_imag**2;
                const forward_power = vf_magnitude_squared / (2 * R_cavity) / 1000; // kW
                const vr_magnitude_squared = vr_real**2 + vr_imag**2;
                const reflected_power = vr_magnitude_squared / (2 * R_cavity) / 1000; // kW
                
                // Stored energy (CORRECTED to match Python exactly)
                const vc_magnitude_squared = this.vc_complex.real**2 + this.vc_complex.imag**2;
                const stored_energy = vc_magnitude_squared * this.Q_loaded / (2 * R_cavity * 2 * Math.PI * this.f0);
                
                return {
                    time: this.time * 1e6, // Convert to microseconds
                    vc_magnitude: vc_magnitude / 1e6, // Convert to MV
                    vc_phase: vc_phase,
                    vr_magnitude: vr_magnitude / 1e6, // Convert to MV
                    forward_power: forward_power,
                    reflected_power: reflected_power,
                    detuning: dw_micr / (2 * Math.PI), // Convert to Hz
                    beam_current: this.beam_current,
                    stored_energy: stored_energy,
                    vf_magnitude: Math.sqrt(vf_magnitude_squared) / 1e6 // Forward voltage in MV
                };
            }
        }
        
        let jsResults = [];
        
        function runJavaScriptTest() {
            const output = document.getElementById('output');
            output.innerHTML = '<div class="output"><h3>Running JavaScript Test...</h3></div>';
            
            // Set same random seed approach (though not exact match)
            Math.seedrandom = function(seed) {
                // Simple seeded random - not perfect but helps consistency
                let m_w = seed;
                let m_z = 987654321;
                return function() {
                    m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & 0xffffffff;
                    m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & 0xffffffff;
                    let result = ((m_z << 16) + m_w) & 0xffffffff;
                    result /= 4294967296;
                    return 0.5 + (result % 1);
                };
            };
            
            // Simple seeded random for testing
            let rand_seed = 42;
            Math.random = function() {
                rand_seed = (rand_seed * 9301 + 49297) % 233280;
                return rand_seed / 233280;
            };
            
            const sim = new JavaScriptCavitySimulator();
            jsResults = [];
            
            let htmlOutput = '<div class="output">';
            htmlOutput += '<h3>JavaScript Simulation Results:</h3>';
            htmlOutput += '<pre>';
            
            // Run 100 steps
            for (let i = 0; i < 100; i++) {
                const result = sim.step();
                jsResults.push(result);
                
                // Print every 20 steps
                if (i % 20 === 0) {
                    htmlOutput += `Step ${i.toString().padStart(3)}: `;
                    htmlOutput += `Vc=${result.vc_magnitude.toFixed(3)} MV, `;
                    htmlOutput += `Pf=${result.forward_power.toFixed(1)} kW, `;
                    htmlOutput += `Pr=${result.reflected_power.toFixed(1)} kW, `;
                    htmlOutput += `Det=${result.detuning.toFixed(1)} Hz\n`;
                }
            }
            
            // Final results
            const final = jsResults[jsResults.length - 1];
            htmlOutput += '</pre>';
            htmlOutput += '<div class="final-results">';
            htmlOutput += '<h4>FINAL JAVASCRIPT VALUES (Step 100):</h4>';
            htmlOutput += `Cavity Voltage: ${final.vc_magnitude.toFixed(6)} MV<br>`;
            htmlOutput += `Cavity Phase: ${final.vc_phase.toFixed(3)}°<br>`;
            htmlOutput += `Forward Power: ${final.forward_power.toFixed(3)} kW<br>`;
            htmlOutput += `Reflected Power: ${final.reflected_power.toFixed(3)} kW<br>`;
            htmlOutput += `Forward Voltage: ${final.vf_magnitude.toFixed(6)} MV<br>`;
            htmlOutput += `Detuning: ${final.detuning.toFixed(3)} Hz<br>`;
            htmlOutput += `Stored Energy: ${final.stored_energy.toFixed(6)} J`;
            htmlOutput += '</div>';
            
            // Calculate averages
            const last50 = jsResults.slice(-50);
            const avgVc = last50.reduce((sum, r) => sum + r.vc_magnitude, 0) / last50.length;
            const avgPf = last50.reduce((sum, r) => sum + r.forward_power, 0) / last50.length;
            const avgPr = last50.reduce((sum, r) => sum + r.reflected_power, 0) / last50.length;
            
            htmlOutput += '<h4>STEADY STATE AVERAGES (last 50 steps):</h4>';
            htmlOutput += `Average Cavity Voltage: ${avgVc.toFixed(6)} MV<br>`;
            htmlOutput += `Average Forward Power: ${avgPf.toFixed(3)} kW<br>`;
            htmlOutput += `Average Reflected Power: ${avgPr.toFixed(3)} kW`;
            htmlOutput += '</div>';
            
            output.innerHTML = htmlOutput;
        }
        
        function runComparison() {
            if (jsResults.length === 0) {
                alert('Please run JavaScript test first!');
                return;
            }
            
            const output = document.getElementById('output');
            const final = jsResults[jsResults.length - 1];
            
            let htmlOutput = '<div class="comparison">';
            htmlOutput += '<h3>Expected Python vs JavaScript Comparison:</h3>';
            htmlOutput += '<p><strong>Note:</strong> For exact comparison, run python_reference_test.py with same parameters.</p>';
            htmlOutput += '<table border="1" style="width:100%; border-collapse: collapse;">';
            htmlOutput += '<tr><th>Parameter</th><th>JavaScript Value</th><th>Expected Range</th><th>Status</th></tr>';
            
            // Expected ranges based on Python reference results
            const checks = [
                ['Forward Power', `${final.forward_power.toFixed(3)} kW`, '~23 kW', Math.abs(final.forward_power - 23.2) < 5 ? '✅' : '❌'],
                ['Cavity Voltage', `${final.vc_magnitude.toFixed(3)} MV`, '0.2-0.5 MV', final.vc_magnitude > 0.1 && final.vc_magnitude < 1.0 ? '✅' : '❌'],
                ['Forward Voltage', `${final.vf_magnitude.toFixed(3)} MV`, '~12 MV', Math.abs(final.vf_magnitude - 12) < 1 ? '✅' : '❌'],
                ['Reflected Power', `${final.reflected_power.toFixed(3)} kW`, '~23 kW', Math.abs(final.reflected_power - 23.3) < 5 ? '✅' : '❌']
            ];
            
            checks.forEach(([param, jsVal, expected, status]) => {
                htmlOutput += `<tr><td>${param}</td><td>${jsVal}</td><td>${expected}</td><td>${status}</td></tr>`;
            });
            
            htmlOutput += '</table>';
            htmlOutput += '<p><strong>Next Step:</strong> Run python_reference_test.py for exact numerical comparison.</p>';
            htmlOutput += '</div>';
            
            output.innerHTML += htmlOutput;
        }
        
        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }
    </script>
</body>
</html>
