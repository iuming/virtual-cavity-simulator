<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exact Python-JavaScript Comparison</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .output { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; white-space: pre-wrap; }
        .header { background: #007bff; color: white; padding: 10px; margin: -20px -20px 20px -20px; border-radius: 8px 8px 0 0; }
        .comparison { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .python-result { background: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 5px; }
        .js-result { background: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px; }
        .match { background: #d1ecf1; border: 1px solid #bee5eb; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #0056b3; }
        .error { color: red; font-weight: bold; }
        .success { color: green; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h2>Exact Python-JavaScript Cavity Simulator Comparison</h2>
        </div>
        
        <p>This test ensures JavaScript calculations match Python exactly, step by step.</p>
        
        <button onclick="runExactComparison()">Run Exact Comparison Test</button>
        <button onclick="clearOutput()">Clear Output</button>
        
        <div id="output"></div>
    </div>

    <script>
        // Seeded Random Number Generator for consistent comparison
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            
            // Simple LCG (Linear Congruential Generator) - same as used in many implementations
            random() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
            
            // Normal distribution using Box-Muller transform
            randn() {
                if (this.spare !== undefined) {
                    const temp = this.spare;
                    this.spare = undefined;
                    return temp;
                }
                
                const u = this.random();
                const v = this.random();
                const mag = Math.sqrt(-2.0 * Math.log(u));
                this.spare = mag * Math.cos(2.0 * Math.PI * v);
                return mag * Math.sin(2.0 * Math.PI * v);
            }
        }

        // JavaScript Cavity Simulator - EXACT Python match
        class ExactCavitySimulator {
            constructor() {
                // Simulation parameters (EXACTLY matching Python)
                this.Ts = 1e-6;  // Time step
                this.f0 = 1.3e9;  // Cavity frequency
                this.QL = 3e6;   // Loaded Q
                this.roQ = 1036; // R/Q
                this.beta = 1e4; // Coupling
                this.RL = 0.5 * this.roQ * this.QL;
                
                // Derived parameters
                this.wh = Math.PI * this.f0 / this.QL;  // Half bandwidth
                this.gain_dB = 20 * Math.log10(12e6);   // Amplifier gain
                this.gain_linear = Math.pow(10, this.gain_dB / 20.0);
                
                // Initial state
                this.vc = { real: 0.0, imag: 0.0 };  // Complex cavity voltage
                this.time = 0.0;
                this.step_count = 0;
                
                // Control parameters
                this.amp = 1.0;
                this.phase = 0.0;  // degrees
                this.fsrc = -460.0;  // Hz
                this.beam_current = 0.008;  // A
                
                // Random number generator
                this.rng = new SeededRandom(42);  // Same seed as Python
                
                console.log('JavaScript Simulator Initialized (Exact Match):');
                console.log(`  Half bandwidth: ${this.wh.toExponential(3)} rad/s`);
                console.log(`  Gain (dB): ${this.gain_dB.toFixed(1)}`);
                console.log(`  Gain (linear): ${this.gain_linear.toExponential(3)}`);
                console.log(`  RL: ${this.RL.toExponential(3)} Ohms`);
            }
            
            sim_amp(sig_real, sig_imag, gain_dB) {
                // Amplifier simulation (matching Python exactly)
                const gain = Math.pow(10, gain_dB / 20.0);
                return {
                    real: sig_real * gain,
                    imag: sig_imag * gain
                };
            }
            
            sim_scav_step_simplified(wh, dw_step0, detuning0, vf_real, vf_imag, vb, state_vc_real, state_vc_imag, Ts, beta) {
                // Cavity step simulation (EXACTLY matching Python)
                
                // Coupled forward voltage
                const vf_coupled_real = beta * vf_real / (beta + 1);
                const vf_coupled_imag = beta * vf_imag / (beta + 1);
                
                // Total drive
                const drive_total_real = 2 * wh * (vf_coupled_real + vb);
                const drive_total_imag = 2 * wh * (vf_coupled_imag + 0);
                
                // Cavity dynamics factor: factor = 1 - Ts * (wh - 1j * detuning0)
                const factor_real = 1 - Ts * wh;
                const factor_imag = Ts * detuning0;  // Note: +Ts*detuning0 because of -1j
                
                // Update cavity voltage: vc_new = factor * state_vc + Ts * drive_total
                // Complex multiplication: (a + jb) * (c + jd) = (ac - bd) + j(ad + bc)
                const vc_new_real = (factor_real * state_vc_real - factor_imag * state_vc_imag) + Ts * drive_total_real;
                const vc_new_imag = (factor_real * state_vc_imag + factor_imag * state_vc_real) + Ts * drive_total_imag;
                
                // Calculate reflected voltage: vr = state_vc - vf_step
                const vr_real = state_vc_real - vf_real;
                const vr_imag = state_vc_imag - vf_imag;
                
                return {
                    vc_real: vc_new_real,
                    vc_imag: vc_new_imag,
                    vr_real: vr_real,
                    vr_imag: vr_imag,
                    dw: detuning0
                };
            }
            
            step() {
                // Execute one simulation step (EXACTLY matching Python)
                
                // Update time
                this.time += this.Ts;
                this.step_count += 1;
                
                // RF source (base signal) - EXACTLY matching Python
                // S0 = self.amp * np.exp(1j * np.deg2rad(self.phase)) * np.exp(1j * 2 * np.pi * self.fsrc * self.time)
                const phase_rad = this.phase * Math.PI / 180;
                const freq_phase = 2 * Math.PI * this.fsrc * this.time;
                const total_phase = phase_rad + freq_phase;
                
                const S0_real = this.amp * Math.cos(total_phase);
                const S0_imag = this.amp * Math.sin(total_phase);
                
                // Apply amplifier gain
                const S2 = this.sim_amp(S0_real, S0_imag, this.gain_dB);
                
                // Beam voltage
                const vb = -this.RL * this.beam_current;
                
                // Microphonics (simple random detuning) - EXACTLY matching Python
                const dw_micr = 2.0 * Math.PI * this.rng.randn() * 10;
                
                // Cavity simulation
                const result = this.sim_scav_step_simplified(
                    this.wh, 0, dw_micr, S2.real, S2.imag, vb, 
                    this.vc.real, this.vc.imag, this.Ts, this.beta
                );
                
                // Update state
                this.vc.real = result.vc_real;
                this.vc.imag = result.vc_imag;
                
                // Calculate results - EXACTLY matching Python
                const vc_magnitude = Math.sqrt(this.vc.real**2 + this.vc.imag**2);
                const vc_phase = Math.atan2(this.vc.imag, this.vc.real) * 180 / Math.PI;
                const vr_magnitude = Math.sqrt(result.vr_real**2 + result.vr_imag**2);
                
                // Power calculations - EXACTLY matching Python
                const R_cavity = this.roQ * this.QL;
                const S2_magnitude_squared = S2.real**2 + S2.imag**2;
                const forward_power = S2_magnitude_squared / (2 * R_cavity) / 1000;  // kW
                const reflected_power = (result.vr_real**2 + result.vr_imag**2) / (2 * R_cavity) / 1000;  // kW
                
                // Stored energy - EXACTLY matching Python
                const stored_energy = (this.vc.real**2 + this.vc.imag**2) * this.QL / (2 * R_cavity * 2 * Math.PI * this.f0);
                
                return {
                    time: this.time * 1e6,  // Convert to microseconds
                    vc_magnitude: vc_magnitude / 1e6,  // Convert to MV
                    vc_phase: vc_phase,
                    vr_magnitude: vr_magnitude / 1e6,  // Convert to MV
                    forward_power: forward_power,
                    reflected_power: reflected_power,
                    detuning: dw_micr / (2 * Math.PI),  // Convert to Hz
                    beam_current: this.beam_current,
                    stored_energy: stored_energy,
                    vf_magnitude: Math.sqrt(S2_magnitude_squared) / 1e6  // Forward voltage in MV
                };
            }
        }

        function runExactComparison() {
            const output = document.getElementById('output');
            output.innerHTML = '<div class="output">Running exact comparison...</div>';
            
            // Create simulator
            const sim = new ExactCavitySimulator();
            
            let htmlOutput = '<div class="comparison">';
            
            // Python results (from our previous test)
            const pythonResults = [
                // Step 0, 20, 40, 60, 80, 100 - extracted from Python output
                {step: 0, vc: 0.001, pf: 23.2, pr: 23.2, det: 5.0},
                {step: 20, vc: 0.033, pf: 23.2, pr: 23.3, det: 14.7},
                {step: 40, vc: 0.094, pf: 23.2, pr: 23.3, det: 7.4},
                {step: 60, vc: 0.191, pf: 23.2, pr: 23.4, det: -4.8},
                {step: 80, vc: 0.322, pf: 23.2, pr: 23.3, det: -2.2}
            ];
            
            htmlOutput += '<div class="python-result"><h3>Python Reference Results:</h3><pre>';
            pythonResults.forEach(r => {
                htmlOutput += `Step ${r.step.toString().padStart(3)}: Vc=${r.vc.toFixed(3)} MV, Pf=${r.pf.toFixed(1)} kW, Pr=${r.pr.toFixed(1)} kW, Det=${r.det.toFixed(1)} Hz\n`;
            });
            htmlOutput += '</pre></div>';
            
            // Run JavaScript simulation
            htmlOutput += '<div class="js-result"><h3>JavaScript Results:</h3><pre>';
            const jsResults = [];
            
            for (let i = 0; i <= 100; i++) {
                const result = sim.step();
                jsResults.push(result);
                
                // Compare with Python at key steps
                if ([0, 20, 40, 60, 80].includes(i)) {
                    htmlOutput += `Step ${i.toString().padStart(3)}: Vc=${result.vc_magnitude.toFixed(3)} MV, Pf=${result.forward_power.toFixed(1)} kW, Pr=${result.reflected_power.toFixed(1)} kW, Det=${result.detuning.toFixed(1)} Hz\n`;
                }
            }
            htmlOutput += '</pre></div>';
            htmlOutput += '</div>';
            
            // Final comparison
            const final = jsResults[jsResults.length - 1];
            htmlOutput += '<div class="output">';
            htmlOutput += '<h3>Final Comparison (Step 100):</h3>';
            htmlOutput += '<table border="1" style="width:100%; border-collapse: collapse;">';
            htmlOutput += '<tr><th>Parameter</th><th>Python</th><th>JavaScript</th><th>Difference</th><th>Status</th></tr>';
            
            // Expected Python final values (from our test)
            const pythonFinal = {
                vc_magnitude: 0.478574,
                forward_power: 23.166,
                reflected_power: 23.277,
                vf_magnitude: 12.000000,
                stored_energy: 0.013533
            };
            
            const comparisons = [
                ['Cavity Voltage (MV)', pythonFinal.vc_magnitude, final.vc_magnitude],
                ['Forward Power (kW)', pythonFinal.forward_power, final.forward_power],
                ['Reflected Power (kW)', pythonFinal.reflected_power, final.reflected_power],
                ['Forward Voltage (MV)', pythonFinal.vf_magnitude, final.vf_magnitude],
                ['Stored Energy (J)', pythonFinal.stored_energy, final.stored_energy]
            ];
            
            comparisons.forEach(([param, pyVal, jsVal]) => {
                const diff = Math.abs(pyVal - jsVal);
                const relError = diff / Math.abs(pyVal) * 100;
                const status = relError < 1 ? '<span class="success">✅ MATCH</span>' : '<span class="error">❌ DIFF</span>';
                
                htmlOutput += `<tr>`;
                htmlOutput += `<td>${param}</td>`;
                htmlOutput += `<td>${pyVal.toFixed(6)}</td>`;
                htmlOutput += `<td>${jsVal.toFixed(6)}</td>`;
                htmlOutput += `<td>${diff.toFixed(6)} (${relError.toFixed(2)}%)</td>`;
                htmlOutput += `<td>${status}</td>`;
                htmlOutput += `</tr>`;
            });
            
            htmlOutput += '</table>';
            htmlOutput += '</div>';
            
            output.innerHTML = htmlOutput;
        }
        
        function clearOutput() {
            document.getElementById('output').innerHTML = '';
        }
    </script>
</body>
</html>
